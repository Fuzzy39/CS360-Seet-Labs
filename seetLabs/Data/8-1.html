<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<p>Reading 8: Arrays and Collections</p>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<p>Arrays and Collections</p>
	<h1>What is an Array?</h1>
	<p>An <b>array</b> is a fixed-size container that holds elements of the same type, offering <b>fast random access</b> via zero-based indexing. Once created, its length cannot change, making it <b>immutable</b> in size. Arrays are stored in contiguous memory, which enables quick lookups by calculating the memory offset. Use arrays when you know the exact number of elements in advance and require efficient access. For dynamic sizes, consider collections.</p>
	<h1>Declaring and Instantiating</h1>
	<p>To declare an array, specify the type and brackets. You can instantiate later or inline with values. Examples:</p>
	<pre><code class="language-java">// Declare then instantiate<br>&#10;int[] nums; <br>&#10;nums = new int[5]; // default values: 0<br>&#10;<br>&#10;// Declare and initialize<br>&#10;String[] names = { "Alice", "Bob", "Charlie" };</code></pre>
	<p><br>&#10;Instantiation with <span class="keyword">new</span> reserves memory and sets default values (0 for numbers, false for booleans, null for objects). Inline initialization skips default and sets specified values directly.</p>
	<h1>Accessing and Modifying</h1>
	<p>Use the <b>index</b> in square brackets to get or set elements. Indexing starts at 0 and goes to <b>length - 1</b>. Examples:</p>
	<pre><code class="language-java">nums[0] = 10; // set first element<br>&#10;int first = nums[0]; // get first element<br>&#10;nums[nums.length - 1] = 99; // set last element</code></pre>
	<p><br>&#10;Accessing an invalid index (negative or >= length) throws <span class="keyword">IndexOutOfBoundsException</span> at runtime. Always validate indexes if they come from user input.</p>
	<h1>Looping Through Arrays</h1>
	<p>Classic <span class="keyword">for</span> loops give you control over index:</p>
	<pre><code class="language-java">for (int i = 0; i < nums.length; i++) {<br>&#10;&#9;System.out.println("Element at " + i + ": " + nums[i]);<br>&#10;}</code></pre>
	<p><br>&#10;Enhanced <span class="keyword">for-each</span> loops simplify iteration when index is not needed:</p>
	<pre><code class="language-java">for (int num : nums) {<br>&#10;&#9;System.out.println(num);<br>&#10;}</code></pre>
	<p><br>&#10;Combine loops with conditionals for filtering or transformations, e.g., collecting even numbers.</p>
	<h1>Multidimensional Arrays</h1>
	<p>Multidimensional arrays are arrays of arrays, forming grids or matrices. Declare with multiple brackets:</p>
	<pre><code class="language-java">int[][] matrix = new int[3][4];<br>&#10;matrix[1][2] = 5; // second row, third column<br>&#10;<br>&#10;// Jagged array example<br>&#10;int[][] jagged = { {1}, {2,3}, {4,5,6} };</code></pre>
	<p><br>&#10;Iterate with nested loops:</p>
	<pre><code class="language-java">for (int i = 0; i < matrix.length; i++) {<br>&#10;&#9;for (int j = 0; j < matrix[i].length; j++) {<br>&#10;&#9;&#9;System.out.print(matrix[i][j] + " ");<br>&#10;&#9;}<br>&#10;&#9;System.out.println();<br>&#10;}</code></pre>
	<p><br>&#10;Use multidimensional arrays for game boards, tables, and image data.</p>
	<h1>Collections Framework Overview</h1>
	<p>Java's <b>Collections Framework</b> provides dynamic, resizable data structures. Key interfaces include <b>List</b> (ordered), <b>Set</b> (unique elements), and <b>Map</b> (key-value pairs). Implementations like <b>ArrayList</b>, <b>LinkedList</b>, <b>HashSet</b>, and <b>HashMap</b> handle common use cases with built-in methods for adding, removing, and querying elements. Collections handle resizing internally, making them ideal when element counts vary at runtime.</p>
	<h1>Lists in Depth</h1>
	<p><b>List</b> interface supports ordered collections that may contain duplicates. <b>ArrayList</b> uses a dynamic array; it offers O(1) random access but O(n) insertions in the middle. <b>LinkedList</b> uses a doubly-linked list; it has O(1) insertions/deletions at ends but O(n) access by index. Choose based on performance needs. Example operations:</p>
	<pre><code class="language-java">list.add("A");<br>&#10;list.get(2);<br>&#10;list.remove(0);<br>&#10;list.size();</code></pre>
	<p><br>&#10;Use <b>ListIterator</b> for bidirectional traversal and element modifications during iteration.</p>
	<h1>Sets and Their Uses</h1>
	<p><b>Set</b> ensures no duplicates. <b>HashSet</b> provides O(1) add/contains via hashing. <b>LinkedHashSet</b> preserves insertion order with a linked list. <b>TreeSet</b> sorts elements using a red-black tree with O(log n) operations. Sets are ideal for membership tests, removing duplicates, and maintaining unique collections.</p>
	<h1>Maps: Key-Value Storage</h1>
	<p><b>Map</b> stores associations between keys and values. <b>HashMap</b> offers O(1) average operations. <b>LinkedHashMap</b> preserves insertion order, and <b>TreeMap</b> sorts keys. Example:</p>
	<pre><code class="language-java">Map<String, Integer> ages = new HashMap<>();<br>&#10;ages.put("Alice", 30);<br>&#10;ages.get("Bob");<br>&#10;ages.containsKey("Alice");<br>&#10;ages.remove("Charlie");</code></pre>
	<p><br>&#10;Maps support bulk operations via <b>putAll</b> and iteration over entry sets.</p>
	<h1>Iterators and Enhanced Traversal</h1>
	<p><b>Iterator</b> allows safe removal during iteration. Example:</p>
	<pre><code class="language-java">Iterator<String> it = list.iterator();<br>&#10;while (it.hasNext()) {<br>&#10;&#9;String s = it.next();<br>&#10;&#9;if (s.isEmpty()) it.remove();<br>&#10;}</code></pre>
	<p><br>&#10;Use <b>forEach</b> and lambda expressions (Module 10) for concise traversal: </p>
	<pre><code class="language-java">list.forEach(item -> System.out.println(item));</code></pre>
	<p></p>
	<h1>Utility Classes: Arrays and Collections</h1>
	<p>The <b>Arrays</b> class offers static methods for arrays: </p>
	<pre><code class="language-java">sort</code></pre>
	<p>, </p>
	<pre><code class="language-java">binarySearch</code></pre>
	<p>, </p>
	<pre><code class="language-java">copyOf</code></pre>
	<p>, and </p>
	<pre><code class="language-java">tomList</code></pre>
	<p>. The <b>Collections</b> class provides algorithms for collections: </p>
	<pre><code class="language-java">reverse</code></pre>
	<p>, </p>
	<pre><code class="language-java">shuffle</code></pre>
	<p>, </p>
	<pre><code class="language-java">max</code></pre>
	<p>, and </p>
	<pre><code class="language-java">min</code></pre>
	<p>. Example:</p>
	<pre><code class="language-java">Arrays.sort(nums);<br>&#10;int pos = Arrays.binarySearch(nums, 5);<br>&#10;Collections.reverse(list);</code></pre>
	<p> Use these utilities to avoid reinventing common algorithms.</p>
	<h1>Thread-Safe Collections</h1>
	<p>In multi-threaded contexts, use concurrent collections like <b>ConcurrentHashMap</b>, <b>CopyOnWriteArrayList</b>, and <b>BlockingQueue</b>. These classes handle synchronization internally, preventing data races and ensuring safe access from multiple threads.</p>
	<h1>Best Practices</h1>
	<p>- Prefer collections over arrays when size varies.<br>&#10;- Use generics to enforce type safety (e.g., List<String>).<br>&#10;- Choose the right implementation for performance (ArrayList vs LinkedList).<br>&#10;- Avoid modifying a collection while iterating; use iterators or streams.<br>&#10;- Always specify initial capacity when possible to reduce resizing overhead.<br>&#10;- Leverage utility methods in Arrays and Collections for common tasks.</p>
</body>
</html>
