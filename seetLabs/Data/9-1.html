<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<p>Reading 9: Data Structures and Generics</p>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<p>Data Structures and Generics</p>
	<h1>Stack, Queue, Deque</h1>
	<p>A <b>Stack</b> follows Last-In-First-Out (LIFO) order, meaning the most recently added element is the first to be removed. You push elements onto the top and pop them off. Internally, a Stack can be backed by a linked list or dynamic array. Use it for undo mechanisms or expression evaluation. In contrast, a <b>Queue</b> uses First-In-First-Out (FIFO), adding at the tail and removing from the head—ideal for task scheduling and breadth-first search. The <b>Deque</b> (Double-Ended Queue) combines both behaviors, allowing insertion and removal at both ends, supporting stack and queue operations in one structure. It’s useful for sliding-window algorithms and palindrome checking.</p>
	<pre><code class="language-java">Stack<Integer> stack = new Stack<>();<br>&#10;stack.push(10);<br>&#10;int top = stack.pop();</code></pre>
	<p></p>
	<h1>LinkedList vs ArrayList</h1>
	<p><b>LinkedList</b> implements a doubly-linked list: each element holds references to its neighbors. Insertion and deletion at any position are O(1) operations when you have a reference to the node. However, random access by index is O(n), as it requires traversal. Use LinkedList for queues or when you frequently add/remove in the middle. <b>ArrayList</b>, backed by a dynamic array, offers O(1) random access but O(n) for insertions/deletions (due to shifting elements). It automatically resizes by copying to a larger array when capacity is exceeded. Choose ArrayList for fast access and when additions/removals occur mainly at the end.</p>
	<pre><code class="language-java">List<Integer> list = new LinkedList<>();<br>&#10;List<Integer> arr = new ArrayList<>();</code></pre>
	<p></p>
	<h1>Binary Trees</h1>
	<p><b>Binary trees</b> are hierarchical structures where each node has up to two children (left and right). They enable efficient search, insertion, and deletion operations when balanced. A <b>binary search tree</b> (BST) maintains the invariant: left subtree values < node < right subtree values, allowing O(log n) operations on average. Unbalanced trees degrade to O(n). Binary heaps, implemented as arrays, use a complete binary tree to provide priority queue functionality. Use trees for sorted data, expression parsing, and implementing sets/maps.</p>
	<pre><code class="language-java">class Node { int value; Node left, right; }</code></pre>
	<p></p>
	<h1>HashMap and HashSet in Detail</h1>
	<p><b>HashMap</b> stores key-value pairs using a hash table. It computes hash codes to determine bucket placement. On collisions, buckets use linked lists or balanced trees (Java 8+). Average operations are O(1), but worst-case can be O(n) if many collisions occur. Choose initial capacity and load factor to optimize performance. <b>HashSet</b> uses a HashMap internally, storing elements as keys with dummy values, ensuring uniqueness. Use HashMap for associative arrays and HashSet for membership testing and deduplication.</p>
	<pre><code class="language-java">Map<String, Integer> map = new HashMap<>();<br>&#10;Set<String> set = new HashSet<>();</code></pre>
	<p></p>
	<h1>Generics and Wildcards</h1>
	<p><b>Generics</b> enable type-safe collections and classes by parameterizing types. They eliminate casts and provide compile-time type checking. Wildcards like <b>? extends T</b> allow reading from collections of T or its subclasses, while <b>? super T</b> allow writing to collections of T or its superclasses. Use bounded wildcards to increase API flexibility. For example, </p>
	<pre><code class="language-java">List<? extends Number></code></pre>
	<p> can accept List<Integer> or List<Double>, but you cannot add elements (except null).</p>
	<h1>Creating Generic Classes and Methods</h1>
	<p>Define generic classes and methods with type parameters. For example, a generic container:</p>
	<pre><code class="language-java">class Box<T> {<br>&#10;&#9;private T value;<br>&#10;&#9;public void set(T value) { this.value = value; }<br>&#10;&#9;public T get() { return value; }<br>&#10;}</code></pre>
	<p><br>&#10;You can also define generic methods:</p>
	<pre><code class="language-java">public static <U> void printArray(U[] arr) {<br>&#10;&#9;for (U elem : arr) System.out.println(elem);<br>&#10;}</code></pre>
	<p> Generics support multiple type parameters and bounds: </p>
	<pre><code class="language-java">class Pair<K, V> { ... }</code></pre>
	<p>.</p>
</body>
</html>
