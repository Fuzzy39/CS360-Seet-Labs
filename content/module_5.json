{
    "name" : "module_5",
    "title" : "Module 5: OOP, Interfaces, and Inheritance",
    "number" : 5,
    "activity_count" : 4,
    "content" : {
        "activity1" : {
            "name" : "Reading 5",
            "id" : "5-1",
            "type" : "reading_activity",
            "content" : {
                "1t" : "OOP, Interfaces, and Inheritance",
                "2h1" : "Encapsulation, Abstraction, Inheritance, Polymorphism",
                "2p" : "Object-Oriented Programming (OOP) relies on four core principles: %bEncapsulation%/b (hiding internal details), %bAbstraction%/b (exposing only necessary features), %bInheritance%/b (extending existing code), and %bPolymorphism%/b (treating objects of different types uniformly). These principles help organize complex systems into manageable components.",
                "3h1" : "Creating and Using Interfaces",
                "3p" : "An %kinterface%/k defines a contract of methods without implementation. Any class that %kimplements%/k the interface must provide bodies for its methods. Example:%cinterface Animal {%n%tvoid makeSound();%nt}%n%/c%ccclass Dog implements Animal {%n%tpublic void makeSound() {%n%t%tSystem.out.println(%'Bark!%');%n%t}%nt}%/c Interfaces allow unrelated classes to share common behavior.",
                "4h1" : "Abstract Classes",
                "4p" : "An %kabstract class%/k can include both abstract methods (without body) and concrete methods. It cannot be instantiated directly. Example:%cabstract class Vehicle {%n%tabstract void move();%n%tvoid stop() { System.out.println(%'Stopped%'); }%nt}%n%ccclass Car extends Vehicle {%n%tvoid move() { System.out.println(%'Car moving%'); }%nt}%/c Abstract classes are useful for sharing code among related classes.",
                "5h1" : "Inheritance and Method Overriding",
                "5p" : "%bInheritance%/b lets a subclass reuse fields and methods from a superclass using %kextends%/k. Subclasses can %boverride%/b inherited methods to provide specialized behavior. Example:%cclass Animal {%n%tvoid makeSound() { System.out.println(%'Some sound%'); }%nt}%n%ccclass Cat extends Animal {%n%t@Override%n%tvoid makeSound() { System.out.println(%'Meow%'); }%nt}%/c Overriding requires matching method signature and allows polymorphic calls.",
                "6h1" : "The %ksuper%/k Keyword",
                "6p" : "%ksuper%/k refers to the immediate parent class. Use it to call superclass constructors or methods. Example:%cclass Animal {%n%tString name;%n%tAnimal(String name) { this.name = name; }%nt}%n%ccclass Dog extends Animal {%n%tDog(String name) { super(name); }%n%tvoid printName() { System.out.println(super.name); }%nt}%/c Using %ksuper%/k helps initialize and access inherited members.",
                "7h1" : "Object Class and Common Methods",
                "7p" : "All classes implicitly extend %bObject%/b, which provides methods like %ktoString()%/k, %kequals()%/k, and %khashCode()%/k. Override these for meaningful behavior. Example:%c@Override%npublic String toString() { return %'Dog: %' + name; }%/c",
                "8h1" : "Design Tips",
                "8p" : "- Favor composition over inheritance when possible to reduce tight coupling.%n- Keep interfaces focused: define only related methods.%n- Use abstract classes for shared code and interfaces for behavior contracts.%n- Apply polymorphism to write flexible and extensible code.%n- Document overridden methods with @Override annotation for clarity."
            }
        },
        "activity2" : {
            "name" : "Coding 5",
            "id" : "5-3",
            "type" : "coding_activity",
            "content" : {
                "" : ""
            }
        },
        "activity3" : {
            "name" : "Quiz 5",
            "id" : "5-4",
            "type" : "quiz_activity",
            "content" : {
                "question1" : {
                    "type" : "multiple choice",
                    "question" : "What does the 'implements' keyword indicate in Java?",
                    "options" : {"1" : "Class inheritance", "2" : "Interface implementation", "3" : "Abstract class instantiation", "4" : "Method overriding"},
                    "correct_responses" : ["2"],
                    "points" : 10,
                    "feedback" : {"1" : "Not quite. 'extends' is for inheritance.","2" : "Correct! 'implements' signals interface adoption.","3" : "Abstract classes use 'extends'.","4" : "Overriding uses @Override, not 'implements'."}
                },
                "question2" : {
                    "type" : "true false",
                    "question" : "True/False: Abstract classes can contain both abstract and concrete methods.",
                    "options" : {"1" : "True", "2" : "False"},
                    "correct_responses" : ["1"],
                    "points" : 10,
                    "feedback" : {"1" : "Correct! Abstract classes mix method types.","2" : "Incorrect. They can have concrete methods too."}
                }
            }
        }
    }
}